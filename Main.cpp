//Этот проект создан с помощью классического шаблона
#include <iostream>
#include <vector>

//1. какую лучше структуру использовать, если мы хотим хранить пару : название
//книги - класс книга.при этом название книги будет уникальным, а искать по
//названию мы будем часто.
//2. почему временная сложность удаления из вектора o(n) ? объяснить подробно и
//понятно.
//3. воспользуйтесь источниками и после этого своим языком объясните, почему
//поиск в мапе o(logn) ?
//4. напишите небольшой кусок кода, который продемонстрирует инвалидацию
//итераторов.в комментарии поясните где и почему произошла инвалидация.

int main() {
	setlocale(LC_ALL, "Russian");
	int m, n;


	//1. какую лучше структуру использовать, если мы хотим хранить пару : название
//книги - класс книга.при этом название книги будет уникальным, а искать по
//названию мы будем часто.
	//Для этой задачи оптимально использовать струкруру map. Выглядеть она будет вот так: std::map<std::string, class book> _books;




	//2. почему временная сложность удаления из вектора o(n) ? объяснить подробно и
//понятно.
	//Сложность линейная, потому что если нам нужно удалить, например, 5 элемент, то компилятор считает с  начала вектора, доходит до 5 позиции и удаляет. Соответственно, удалить 0 элемент это 0.01мс ( например )
	// удалить 10 элемент это 0.1 мс ( 0.01 * 10 )




	//3. воспользуйтесь источниками и после этого своим языком объясните, почему
//поиск в мапе o(logn) ?
	//Потому что поиск идет по бинарному дереву. Напрример, у нас 4 элемента, с ключами 3, 8, 5, 1. На нужно найти 1 элемент.
	// Копилятор не просматривает все элементы подряд, а начинается поиск с 1го элемента, дальше элементы с меньшим ключом располагаются в левой ветке, с большим - в правой.
	// 1 меньше, чем 3, поэтомумы идем в левую ветку бинарного дерева. Находим элемент с ключом 1, пропуская ключи 8 и 5. Поэтому сложность логарифмическая.

	//4. напишите небольшой кусок кода, который продемонстрирует инвалидацию
//итераторов.в комментарии поясните где и почему произошла инвалидация.


	std::vector<int>myVector = {10}; //создали интовый вектор и добавили в него 10
	auto it = begin(myVector);//сохранили итератор на это число
	std::cout << *it << std::endl;//вывели в консоль
	myVector.push_back(20);//добавили в вектор 20
	std::cout << *it << std::endl;//тоже выводим в консоль, но возникает ошибка, т е здесь происходит инвалидация итератора















	return 0;
}